{"version":3,"file":"AvroReadableFromStream.js","sourceRoot":"","sources":["../../../../storage-internal-avro/src/AvroReadableFromStream.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AvroReadable, AvroReadableReadOptions } from \"./AvroReadable\";\nimport { AbortError } from \"@azure/abort-controller\";\n\nconst ABORT_ERROR = new AbortError(\"Reading from the avro stream was aborted.\");\n\nexport class AvroReadableFromStream extends AvroReadable {\n  private _position: number;\n  private _readable: NodeJS.ReadableStream;\n\n  private toUint8Array(data: string | Buffer): Uint8Array {\n    if (typeof data === \"string\") {\n      return Buffer.from(data);\n    }\n    return data;\n  }\n\n  constructor(readable: NodeJS.ReadableStream) {\n    super();\n    this._readable = readable;\n    this._position = 0;\n  }\n  public get position(): number {\n    return this._position;\n  }\n  public async read(size: number, options: AvroReadableReadOptions = {}): Promise<Uint8Array> {\n    if (options.abortSignal?.aborted) {\n      throw ABORT_ERROR;\n    }\n\n    if (size < 0) {\n      throw new Error(`size parameter should be positive: ${size}`);\n    }\n\n    if (size === 0) {\n      return new Uint8Array();\n    }\n\n    if (!this._readable.readable) {\n      throw new Error(\"Stream no longer readable.\");\n    }\n    // See if there is already enough data.\n    const chunk = this._readable.read(size);\n    if (chunk) {\n      this._position += chunk.length;\n      // chunk.length maybe less than desired size if the stream ends.\n      return this.toUint8Array(chunk);\n    } else {\n      // register callback to wait for enough data to read\n      return new Promise((resolve, reject) => {\n        const cleanUp = () => {\n          this._readable.removeListener(\"readable\", readableCallback);\n          this._readable.removeListener(\"error\", rejectCallback);\n          this._readable.removeListener(\"end\", rejectCallback);\n          this._readable.removeListener(\"close\", rejectCallback);\n\n          if (options.abortSignal) {\n            options.abortSignal!.removeEventListener(\"abort\", abortHandler);\n          }\n        };\n\n        const readableCallback = () => {\n          const chunk = this._readable.read(size);\n          if (chunk) {\n            this._position += chunk.length;\n            cleanUp();\n            // chunk.length maybe less than desired size if the stream ends.\n            resolve(this.toUint8Array(chunk));\n          }\n        };\n\n        const rejectCallback = () => {\n          cleanUp();\n          reject();\n        };\n\n        const abortHandler = () => {\n          cleanUp();\n          reject(ABORT_ERROR);\n        };\n\n        this._readable.on(\"readable\", readableCallback);\n        this._readable.once(\"error\", rejectCallback);\n        this._readable.once(\"end\", rejectCallback);\n        this._readable.once(\"close\", rejectCallback);\n        if (options.abortSignal) {\n          options.abortSignal!.addEventListener(\"abort\", abortHandler);\n        }\n      });\n    }\n  }\n}\n"]}