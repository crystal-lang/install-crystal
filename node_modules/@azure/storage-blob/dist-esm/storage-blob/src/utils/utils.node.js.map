{"version":3,"file":"utils.node.js","sourceRoot":"","sources":["../../../../src/utils/utils.node.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as fs from \"fs\";\nimport * as util from \"util\";\n\n/**\n * Reads a readable stream into buffer. Fill the buffer from offset to end.\n *\n * @param stream - A Node.js Readable stream\n * @param buffer - Buffer to be filled, length must greater than or equal to offset\n * @param offset - From which position in the buffer to be filled, inclusive\n * @param end - To which position in the buffer to be filled, exclusive\n * @param encoding - Encoding of the Readable stream\n */\nexport async function streamToBuffer(\n  stream: NodeJS.ReadableStream,\n  buffer: Buffer,\n  offset: number,\n  end: number,\n  encoding?: string\n): Promise<void> {\n  let pos = 0; // Position in stream\n  const count = end - offset; // Total amount of data needed in stream\n\n  return new Promise<void>((resolve, reject) => {\n    stream.on(\"readable\", () => {\n      if (pos >= count) {\n        resolve();\n        return;\n      }\n\n      let chunk = stream.read();\n      if (!chunk) {\n        return;\n      }\n      if (typeof chunk === \"string\") {\n        chunk = Buffer.from(chunk, encoding);\n      }\n\n      // How much data needed in this chunk\n      const chunkLength = pos + chunk.length > count ? count - pos : chunk.length;\n\n      buffer.fill(chunk.slice(0, chunkLength), offset + pos, offset + pos + chunkLength);\n      pos += chunkLength;\n    });\n\n    stream.on(\"end\", () => {\n      if (pos < count) {\n        reject(\n          new Error(\n            `Stream drains before getting enough data needed. Data read: ${pos}, data need: ${count}`\n          )\n        );\n      }\n      resolve();\n    });\n\n    stream.on(\"error\", reject);\n  });\n}\n\n/**\n * Reads a readable stream into buffer entirely.\n *\n * @param stream - A Node.js Readable stream\n * @param buffer - Buffer to be filled, length must greater than or equal to offset\n * @param encoding - Encoding of the Readable stream\n * @returns with the count of bytes read.\n * @throws `RangeError` If buffer size is not big enough.\n */\nexport async function streamToBuffer2(\n  stream: NodeJS.ReadableStream,\n  buffer: Buffer,\n  encoding?: string\n): Promise<number> {\n  let pos = 0; // Position in stream\n  const bufferSize = buffer.length;\n\n  return new Promise<number>((resolve, reject) => {\n    stream.on(\"readable\", () => {\n      let chunk = stream.read();\n      if (!chunk) {\n        return;\n      }\n      if (typeof chunk === \"string\") {\n        chunk = Buffer.from(chunk, encoding);\n      }\n\n      if (pos + chunk.length > bufferSize) {\n        reject(new Error(`Stream exceeds buffer size. Buffer size: ${bufferSize}`));\n        return;\n      }\n\n      buffer.fill(chunk, pos, pos + chunk.length);\n      pos += chunk.length;\n    });\n\n    stream.on(\"end\", () => {\n      resolve(pos);\n    });\n\n    stream.on(\"error\", reject);\n  });\n}\n\n/**\n * Reads a readable stream into a buffer.\n *\n * @param stream - A Node.js Readable stream\n * @param encoding - Encoding of the Readable stream\n * @returns with the count of bytes read.\n */\nexport async function streamToBuffer3(\n  readableStream: NodeJS.ReadableStream,\n  encoding?: string\n): Promise<Buffer> {\n  return new Promise((resolve, reject) => {\n    const chunks: Buffer[] = [];\n    readableStream.on(\"data\", (data: Buffer | string) => {\n      chunks.push(data instanceof Buffer ? data : Buffer.from(data, encoding));\n    });\n    readableStream.on(\"end\", () => {\n      resolve(Buffer.concat(chunks));\n    });\n    readableStream.on(\"error\", reject);\n  });\n}\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n *\n * Writes the content of a readstream to a local file. Returns a Promise which is completed after the file handle is closed.\n *\n * @param rs - The read stream.\n * @param file - Destination file path.\n */\nexport async function readStreamToLocalFile(\n  rs: NodeJS.ReadableStream,\n  file: string\n): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    const ws = fs.createWriteStream(file);\n\n    rs.on(\"error\", (err: Error) => {\n      reject(err);\n    });\n\n    ws.on(\"error\", (err: Error) => {\n      reject(err);\n    });\n\n    ws.on(\"close\", resolve);\n\n    rs.pipe(ws);\n  });\n}\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n *\n * Promisified version of fs.stat().\n */\nexport const fsStat = util.promisify(fs.stat);\n\nexport const fsCreateReadStream = fs.createReadStream;\n"]}