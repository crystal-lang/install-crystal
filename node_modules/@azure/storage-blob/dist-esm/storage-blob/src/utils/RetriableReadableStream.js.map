{"version":3,"file":"RetriableReadableStream.js","sourceRoot":"","sources":["../../../../src/utils/RetriableReadableStream.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { TransferProgressEvent } from \"@azure/core-http\";\nimport { Readable } from \"stream\";\n\nexport type ReadableStreamGetter = (offset: number) => Promise<NodeJS.ReadableStream>;\n\nexport interface RetriableReadableStreamOptions {\n  /**\n   * Max retry count (greater than or equal to 0), undefined or invalid value means no retry\n   */\n  maxRetryRequests?: number;\n\n  /**\n   * Read progress event handler\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Debug purpose only. Used to inject an unexpected end to existing internal stream,\n   * to test stream retry works well or not.\n   *\n   * When assign it to true, for next incoming \"data\" event of internal stream,\n   * RetriableReadableStream will try to emit an \"end\" event to existing internal\n   * stream to force it end and start retry from the breaking point.\n   * The value will then update to \"undefined\", once the injection works.\n   */\n  doInjectErrorOnce?: boolean;\n\n  /**\n   * A threshold, not a limit. Dictates the amount of data that a stream buffers before it stops asking for more data.\n   */\n  highWaterMark?: number;\n}\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n *\n * A Node.js ReadableStream will internally retry when internal ReadableStream unexpected ends.\n */\nexport class RetriableReadableStream extends Readable {\n  private start: number;\n  private offset: number;\n  private end: number;\n  private getter: ReadableStreamGetter;\n  private source: NodeJS.ReadableStream;\n  private retries: number = 0;\n  private maxRetryRequests: number;\n  private onProgress?: (progress: TransferProgressEvent) => void;\n  private options: RetriableReadableStreamOptions;\n\n  /**\n   * Creates an instance of RetriableReadableStream.\n   *\n   * @param source - The current ReadableStream returned from getter\n   * @param getter - A method calling downloading request returning\n   *                                      a new ReadableStream from specified offset\n   * @param offset - Offset position in original data source to read\n   * @param count - How much data in original data source to read\n   * @param options -\n   */\n  public constructor(\n    source: NodeJS.ReadableStream,\n    getter: ReadableStreamGetter,\n    offset: number,\n    count: number,\n    options: RetriableReadableStreamOptions = {}\n  ) {\n    super({ highWaterMark: options.highWaterMark });\n    this.getter = getter;\n    this.source = source;\n    this.start = offset;\n    this.offset = offset;\n    this.end = offset + count - 1;\n    this.maxRetryRequests =\n      options.maxRetryRequests && options.maxRetryRequests >= 0 ? options.maxRetryRequests : 0;\n    this.onProgress = options.onProgress;\n    this.options = options;\n\n    this.setSourceEventHandlers();\n  }\n\n  public _read() {\n    this.source.resume();\n  }\n\n  private setSourceEventHandlers() {\n    this.source.on(\"data\", this.sourceDataHandler);\n    this.source.on(\"end\", this.sourceErrorOrEndHandler);\n    this.source.on(\"error\", this.sourceErrorOrEndHandler);\n  }\n\n  private removeSourceEventHandlers() {\n    this.source.removeListener(\"data\", this.sourceDataHandler);\n    this.source.removeListener(\"end\", this.sourceErrorOrEndHandler);\n    this.source.removeListener(\"error\", this.sourceErrorOrEndHandler);\n  }\n\n  private sourceDataHandler = (data: Buffer) => {\n    if (this.options.doInjectErrorOnce) {\n      this.options.doInjectErrorOnce = undefined;\n      this.source.pause();\n      this.source.removeAllListeners(\"data\");\n      this.source.emit(\"end\");\n      return;\n    }\n\n    // console.log(\n    //   `Offset: ${this.offset}, Received ${data.length} from internal stream`\n    // );\n    this.offset += data.length;\n    if (this.onProgress) {\n      this.onProgress({ loadedBytes: this.offset - this.start });\n    }\n    if (!this.push(data)) {\n      this.source.pause();\n    }\n  };\n\n  private sourceErrorOrEndHandler = (err?: Error) => {\n    if (err && err.name === \"AbortError\") {\n      this.destroy(err);\n      return;\n    }\n\n    // console.log(\n    //   `Source stream emits end or error, offset: ${\n    //     this.offset\n    //   }, dest end : ${this.end}`\n    // );\n    this.removeSourceEventHandlers();\n    if (this.offset - 1 === this.end) {\n      this.push(null);\n    } else if (this.offset <= this.end) {\n      // console.log(\n      //   `retries: ${this.retries}, max retries: ${this.maxRetries}`\n      // );\n      if (this.retries < this.maxRetryRequests) {\n        this.retries += 1;\n        this.getter(this.offset)\n          .then((newSource) => {\n            this.source = newSource;\n            this.setSourceEventHandlers();\n          })\n          .catch((error) => {\n            this.destroy(error);\n          });\n      } else {\n        this.destroy(\n          new Error(\n            // tslint:disable-next-line:max-line-length\n            `Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: ${this\n              .offset - 1}, data needed offset: ${this.end}, retries: ${\n              this.retries\n            }, max retries: ${this.maxRetryRequests}`\n          )\n        );\n      }\n    } else {\n      this.destroy(\n        new Error(\n          `Data corruption failure: Received more data than original request, data needed offset is ${\n            this.end\n          }, received offset: ${this.offset - 1}`\n        )\n      );\n    }\n  };\n\n  _destroy(error: Error | null, callback: (error?: Error) => void): void {\n    // remove listener from source and release source\n    this.removeSourceEventHandlers();\n    (this.source as Readable).destroy();\n\n    callback(error === null ? undefined : error);\n  }\n}\n"]}