{"version":3,"file":"index.js","sources":["../src/tracers/noop/noOpSpan.ts","../src/tracers/noop/noOpTracer.ts","../src/utils/global.ts","../src/utils/cache.ts","../src/tracerProxy.ts","../src/interfaces.ts","../src/tracers/opencensus/openCensusTraceStateWrapper.ts","../src/tracers/opencensus/openCensusSpanWrapper.ts","../src/tracers/opencensus/openCensusTracerWrapper.ts","../src/tracers/test/testSpan.ts","../src/tracers/test/testTracer.ts","../src/createSpan.ts","../src/utils/traceParentHeader.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  Span,\n  SpanContext,\n  SpanAttributes,\n  SpanStatus,\n  TraceFlags,\n  Exception,\n  TimeInput\n} from \"../../interfaces\";\n\n/**\n * A no-op implementation of Span that can safely be used without side-effects.\n */\nexport class NoOpSpan implements Span {\n  /**\n   * Returns the SpanContext associated with this Span.\n   */\n  context(): SpanContext {\n    return {\n      spanId: \"\",\n      traceId: \"\",\n      traceFlags: TraceFlags.NONE\n    };\n  }\n\n  /**\n   * Marks the end of Span execution.\n   * @param _endTime - The time to use as the Span's end time. Defaults to\n   * the current time.\n   */\n  end(_endTime?: number): void {\n    /* Noop */\n  }\n\n  /**\n   * Sets an attribute on the Span\n   * @param _key - The attribute key\n   * @param _value - The attribute value\n   */\n  setAttribute(_key: string, _value: unknown): this {\n    return this;\n  }\n\n  /**\n   * Sets attributes on the Span\n   * @param _attributes - The attributes to add\n   */\n  setAttributes(_attributes: SpanAttributes): this {\n    return this;\n  }\n\n  /**\n   * Adds an event to the Span\n   * @param _name - The name of the event\n   * @param _attributes - The associated attributes to add for this event\n   */\n  addEvent(_name: string, _attributes?: SpanAttributes): this {\n    return this;\n  }\n\n  /**\n   * Sets a status on the span. Overrides the default of SpanStatusCode.OK.\n   * @param _status - The status to set.\n   */\n  setStatus(_status: SpanStatus): this {\n    return this;\n  }\n\n  /**\n   * Updates the name of the Span\n   * @param _name - the new Span name\n   */\n  updateName(_name: string): this {\n    return this;\n  }\n\n  /**\n   * Returns whether this span will be recorded\n   */\n  isRecording(): boolean {\n    return false;\n  }\n\n  /**\n   * Sets exception as a span event\n   * @param exception - the exception the only accepted values are string or Error\n   * @param time - the time to set as Span's event time. If not provided,\n   *     use the current time.\n   */\n  recordException(_exception: Exception, _time?: TimeInput): void {\n    /* do nothing */\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { NoOpSpan } from \"./noOpSpan\";\nimport { Span, SpanOptions, Tracer } from \"../../interfaces\";\n\n/**\n * A no-op implementation of Tracer that can be used when tracing\n * is disabled.\n */\nexport class NoOpTracer implements Tracer {\n  /**\n   * Starts a new Span.\n   * @param _name - The name of the span.\n   * @param _options - The SpanOptions used during Span creation.\n   */\n  startSpan(_name: string, _options?: SpanOptions): Span {\n    return new NoOpSpan();\n  }\n\n  /**\n   * Returns the current Span from the current context, if available.\n   */\n  getCurrentSpan(): Span {\n    return new NoOpSpan();\n  }\n\n  /**\n   * Executes the given function within the context provided by a Span.\n   * @param _span - The span that provides the context.\n   * @param fn - The function to be executed.\n   */\n  withSpan<T extends (...args: unknown[]) => ReturnType<T>>(_span: Span, fn: T): ReturnType<T> {\n    return fn();\n  }\n\n  /**\n   * Bind a Span as the target's scope\n   * @param target - An object to bind the scope.\n   * @param _span - A specific Span to use. Otherwise, use the current one.\n   */\n  bind<T>(target: T, _span?: Span): T {\n    return target;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nexport function getGlobalObject(): any {\n  return global;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Tracer } from \"../interfaces\";\nimport { getGlobalObject } from \"./global\";\n\n// V1 = OpenTelemetry 0.1\n// V2 = OpenTelemetry 0.2\n// V3 = OpenTelemetry 0.6.1\n// V4 = OpenTelemetry 1.0.0-rc.0\nconst GLOBAL_TRACER_VERSION = 4;\n// preview5 shipped with @azure/core-tracing.tracerCache\n// and didn't have smart detection for collisions\nconst GLOBAL_TRACER_SYMBOL = Symbol.for(\"@azure/core-tracing.tracerCache3\");\n\nexport interface TracerCache {\n  version: number;\n  tracer?: Tracer;\n}\n\nlet cache: TracerCache;\n\nfunction loadTracerCache(): void {\n  const globalObj = getGlobalObject();\n  const existingCache: TracerCache = globalObj[GLOBAL_TRACER_SYMBOL];\n  let setGlobalCache = true;\n  if (existingCache) {\n    if (existingCache.version === GLOBAL_TRACER_VERSION) {\n      cache = existingCache;\n    } else {\n      setGlobalCache = false;\n      if (existingCache.tracer) {\n        throw new Error(\n          `Two incompatible versions of @azure/core-tracing have been loaded.\n          This library is ${GLOBAL_TRACER_VERSION}, existing is ${existingCache.version}.`\n        );\n      }\n    }\n  }\n\n  if (!cache) {\n    cache = {\n      tracer: undefined,\n      version: GLOBAL_TRACER_VERSION\n    };\n  }\n  if (setGlobalCache) {\n    globalObj[GLOBAL_TRACER_SYMBOL] = cache;\n  }\n}\n\nexport function getCache(): TracerCache {\n  if (!cache) {\n    loadTracerCache();\n  }\n  return cache;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { NoOpTracer } from \"./tracers/noop/noOpTracer\";\nimport { Tracer } from \"./interfaces\";\nimport { getCache } from \"./utils/cache\";\n\nlet defaultTracer: Tracer;\n\nfunction getDefaultTracer(): Tracer {\n  if (!defaultTracer) {\n    defaultTracer = new NoOpTracer();\n  }\n  return defaultTracer;\n}\n\n/**\n * Sets the global tracer, enabling tracing for the Azure SDK.\n * @param tracer - An OpenTelemetry Tracer instance.\n */\nexport function setTracer(tracer: Tracer): void {\n  const cache = getCache();\n  cache.tracer = tracer;\n}\n\n/**\n * Retrieves the active tracer, or returns a\n * no-op implementation if one is not set.\n */\nexport function getTracer(): Tracer {\n  const cache = getCache();\n  if (!cache.tracer) {\n    return getDefaultTracer();\n  }\n  return cache.tracer;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  context as otContext,\n  getSpan as otGetSpan,\n  getSpanContext as otGetSpanContext,\n  setSpan as otSetSpan,\n  setSpanContext as otSetSpanContext\n} from \"@opentelemetry/api\";\n\n/**\n * A Tracer.\n */\nexport interface Tracer {\n  /**\n   * Starts a new {@link Span}. Start the span without setting it on context.\n   *\n   * This method does NOT modify the current Context.\n   *\n   * @param name - The name of the span\n   * @param options - SpanOptions used for span creation\n   * @param context - Context to use to extract parent\n   * @returns The newly created span\n   * @example\n   *     const span = tracer.startSpan('op');\n   *     span.setAttribute('key', 'value');\n   *     span.end();\n   */\n  startSpan(name: string, options?: SpanOptions, context?: Context): Span;\n}\n\n/**\n * TraceState.\n */\nexport interface TraceState {\n  /**\n   * Create a new TraceState which inherits from this TraceState and has the\n   * given key set.\n   * The new entry will always be added in the front of the list of states.\n   *\n   * @param key - key of the TraceState entry.\n   * @param value - value of the TraceState entry.\n   */\n  set(key: string, value: string): TraceState;\n  /**\n   * Return a new TraceState which inherits from this TraceState but does not\n   * contain the given key.\n   *\n   * @param key - the key for the TraceState entry to be removed.\n   */\n  unset(key: string): TraceState;\n  /**\n   * Returns the value to which the specified key is mapped, or `undefined` if\n   * this map contains no mapping for the key.\n   *\n   * @param key - with which the specified value is to be associated.\n   * @returns the value to which the specified key is mapped, or `undefined` if\n   *     this map contains no mapping for the key.\n   */\n  get(key: string): string | undefined;\n  /**\n   * Serializes the TraceState to a `list` as defined below. The `list` is a\n   * series of `list-members` separated by commas `,`, and a list-member is a\n   * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\n   * surrounding `list-members` are ignored. There can be a maximum of 32\n   * `list-members` in a `list`.\n   *\n   * @returns the serialized string.\n   */\n  serialize(): string;\n}\n\n/**\n * Represents high resolution time.\n */\nexport declare type HrTime = [number, number];\n\n/**\n * Used to represent a Time.\n */\nexport type TimeInput = HrTime | number | Date;\n\n/**\n * The status for a span.\n */\nexport interface SpanStatus {\n  /** The status code of this message. */\n  code: SpanStatusCode;\n  /** A developer-facing error message. */\n  message?: string;\n}\n\n/**\n * The kind of span.\n */\nexport enum SpanKind {\n  /** Default value. Indicates that the span is used internally. */\n  INTERNAL = 0,\n  /**\n   * Indicates that the span covers server-side handling of an RPC or other\n   * remote request.\n   */\n  SERVER = 1,\n  /**\n   * Indicates that the span covers the client-side wrapper around an RPC or\n   * other remote request.\n   */\n  CLIENT = 2,\n  /**\n   * Indicates that the span describes producer sending a message to a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  PRODUCER = 3,\n  /**\n   * Indicates that the span describes consumer receiving a message from a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  CONSUMER = 4\n}\n\n/**\n * An Exception for a Span.\n */\nexport declare type Exception =\n  | ExceptionWithCode\n  | ExceptionWithMessage\n  | ExceptionWithName\n  | string;\n\n/**\n * An Exception with a code.\n */\nexport interface ExceptionWithCode {\n  /** The code. */\n  code: string | number;\n  /** The name. */\n  name?: string;\n  /** The message. */\n  message?: string;\n  /** The stack. */\n  stack?: string;\n}\n\n/**\n * An Exception with a message.\n */\nexport interface ExceptionWithMessage {\n  /** The code. */\n  code?: string | number;\n  /** The message. */\n  message: string;\n  /** The name. */\n  name?: string;\n  /** The stack. */\n  stack?: string;\n}\n\n/**\n * An Exception with a name.\n */\nexport interface ExceptionWithName {\n  /** The code. */\n  code?: string | number;\n  /** The message. */\n  message?: string;\n  /** The name. */\n  name: string;\n  /** The stack. */\n  stack?: string;\n}\n\n/**\n * Return the span if one exists\n *\n * @param context - context to get span from\n */\nexport function getSpan(context: Context): Span | undefined {\n  return otGetSpan(context);\n}\n\n/**\n * Set the span on a context\n *\n * @param context - context to use as parent\n * @param span - span to set active\n */\nexport function setSpan(context: Context, span: Span): Context {\n  return otSetSpan(context, span);\n}\n\n/**\n * Wrap span context in a NoopSpan and set as span in a new\n * context\n *\n * @param context - context to set active span on\n * @param spanContext - span context to be wrapped\n */\nexport function setSpanContext(context: Context, spanContext: SpanContext): Context {\n  return otSetSpanContext(context, spanContext);\n}\n\n/**\n * Get the span context of the span if it exists.\n *\n * @param context - context to get values from\n */\nexport function getSpanContext(context: Context): SpanContext | undefined {\n  return otGetSpanContext(context);\n}\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Context API\n */\nexport interface ContextAPI {\n  /**\n   * Get the currently active context\n   */\n  active(): Context;\n}\n\n/** Entrypoint for context API */\nexport const context: ContextAPI = otContext;\n\n/** SpanStatusCode */\nexport enum SpanStatusCode {\n  /**\n   * The default status.\n   */\n  UNSET = 0,\n  /**\n   * The operation has been validated by an Application developer or\n   * Operator to have completed successfully.\n   */\n  OK = 1,\n  /**\n   * The operation contains an error.\n   */\n  ERROR = 2\n}\n\n/**\n * An interface that represents a span. A span represents a single operation\n * within a trace. Examples of span might include remote procedure calls or a\n * in-process function calls to sub-components. A Trace has a single, top-level\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\n * may have children.\n *\n * Spans are created by the {@link Tracer.startSpan} method.\n */\nexport interface Span {\n  /**\n   * Returns the {@link SpanContext} object associated with this Span.\n   *\n   * Get an immutable, serializable identifier for this span that can be used\n   * to create new child spans. Returned SpanContext is usable even after the\n   * span ends.\n   *\n   * @returns the SpanContext object associated with this Span.\n   */\n  context(): SpanContext;\n  /**\n   * Sets an attribute to the span.\n   *\n   * Sets a single Attribute with the key and value passed as arguments.\n   *\n   * @param key - the key for this attribute.\n   * @param value - the value for this attribute. Setting a value null or\n   *              undefined is invalid and will result in undefined behavior.\n   */\n  setAttribute(key: string, value: SpanAttributeValue): this;\n  /**\n   * Sets attributes to the span.\n   *\n   * @param attributes - the attributes that will be added.\n   *                   null or undefined attribute values\n   *                   are invalid and will result in undefined behavior.\n   */\n  setAttributes(attributes: SpanAttributes): this;\n  /**\n   * Adds an event to the Span.\n   *\n   * @param name - the name of the event.\n   * @param attributesOrStartTime -  the attributes that will be added; these are\n   *     associated with this event. Can be also a start time\n   *     if type is TimeInput and 3rd param is undefined\n   * @param startTime - start time of the event.\n   */\n  addEvent(\n    name: string,\n    attributesOrStartTime?: SpanAttributes | TimeInput,\n    startTime?: TimeInput\n  ): this;\n  /**\n   * Sets a status to the span. If used, this will override the default Span\n   * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\n   * of previous calls to SetStatus on the Span.\n   *\n   * @param status - the SpanStatus to set.\n   */\n  setStatus(status: SpanStatus): this;\n  /**\n   * Marks the end of Span execution.\n   *\n   * Call to End of a Span MUST not have any effects on child spans. Those may\n   * still be running and can be ended later.\n   *\n   * Do not return `this`. The Span generally should not be used after it\n   * is ended so chaining is not desired in this context.\n   *\n   * @param endTime - the time to set as Span's end time. If not provided,\n   *     use the current time as the span's end time.\n   */\n  end(endTime?: TimeInput): void;\n  /**\n   * Returns the flag whether this span will be recorded.\n   *\n   * @returns true if this Span is active and recording information like events\n   *     with the `AddEvent` operation and attributes using `setAttributes`.\n   */\n  isRecording(): boolean;\n\n  /**\n   * Sets exception as a span event\n   * @param exception - the exception the only accepted values are string or Error\n   * @param time - the time to set as Span's event time. If not provided,\n   *     use the current time.\n   */\n  recordException(exception: Exception, time?: TimeInput): void;\n\n  /**\n   * Updates the Span name.\n   *\n   * This will override the name provided via {@link Tracer.startSpan}.\n   *\n   * Upon this update, any sampling behavior based on Span name will depend on\n   * the implementation.\n   *\n   * @param name - the Span name.\n   */\n  updateName(name: string): this;\n}\n\n/**\n * Shorthand enum for common traceFlags values inside SpanContext\n */\nexport const enum TraceFlags {\n  /** No flag set. */\n  NONE = 0x0,\n  /** Caller is collecting trace information. */\n  SAMPLED = 0x1\n}\n\n/**\n * A light interface that tries to be structurally compatible with OpenTelemetry\n */\nexport interface SpanContext {\n  /**\n   * UUID of a trace.\n   */\n  traceId: string;\n  /**\n   * UUID of a Span.\n   */\n  spanId: string;\n  /**\n   * https://www.w3.org/TR/trace-context/#trace-flags\n   */\n  traceFlags: number;\n  /**\n   * Tracing-system-specific info to propagate.\n   *\n   * The tracestate field value is a `list` as defined below. The `list` is a\n   * series of `list-members` separated by commas `,`, and a list-member is a\n   * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\n   * surrounding `list-members` are ignored. There can be a maximum of 32\n   * `list-members` in a `list`.\n   * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\n   *\n   * Examples:\n   *     Single tracing system (generic format):\n   *         tracestate: rojo=00f067aa0ba902b7\n   *     Multiple tracing systems (with different formatting):\n   *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\n   */\n  traceState?: TraceState;\n}\n\n/**\n * Context for the linked span.\n */\nexport type LinkContext = {\n  traceId: string;\n  spanId: string;\n};\n\n/**\n * Used to specify a span that is linked to another.\n */\nexport interface Link {\n  /** The {@link LinkContext} of a linked span. */\n  context: LinkContext;\n\n  /** A set of {@link SpanAttributes} on the link. */\n  attributes?: SpanAttributes;\n}\n\n/**\n * Attributes for a Span.\n */\nexport interface SpanAttributes {\n  /**\n   * Attributes for a Span.\n   */\n  [attributeKey: string]: SpanAttributeValue | undefined;\n}\n/**\n * Attribute values may be any non-nullish primitive value except an object.\n *\n * null or undefined attribute values are invalid and will result in undefined behavior.\n */\nexport declare type SpanAttributeValue =\n  | string\n  | number\n  | boolean\n  | Array<null | undefined | string>\n  | Array<null | undefined | number>\n  | Array<null | undefined | boolean>;\n\n/**\n * An interface that enables manual propagation of Spans\n */\nexport interface SpanOptions {\n  /**\n   * Attributes to set on the Span\n   */\n  attributes?: SpanAttributes;\n\n  /** {@link Link}s span to other spans */\n  links?: Link[];\n\n  /**\n   * The type of Span. Default to SpanKind.INTERNAL\n   */\n  kind?: SpanKind;\n\n  /**\n   * A manually specified start time for the created `Span` object.\n   */\n  startTime?: TimeInput;\n}\n\n/**\n * Tracing options to set on an operation.\n */\nexport interface OperationTracingOptions {\n  /**\n   * OpenTelemetry SpanOptions used to create a span when tracing is enabled.\n   */\n  spanOptions?: SpanOptions;\n\n  /**\n   * OpenTelemetry context to use for created Spans.\n   */\n  tracingContext?: Context;\n}\n\n/**\n * OpenTelemetry compatible interface for Context\n */\nexport interface Context {\n  /**\n   * Get a value from the context.\n   *\n   * @param key - key which identifies a context value\n   */\n  getValue(key: symbol): unknown;\n  /**\n   * Create a new context which inherits from this context and has\n   * the given key set to the given value.\n   *\n   * @param key - context key for which to set the value\n   * @param value - value to set for the given key\n   */\n  setValue(key: symbol, value: unknown): Context;\n  /**\n   * Return a new context which inherits from this context but does\n   * not contain a value for the given key.\n   *\n   * @param key - context key for which to clear a value\n   */\n  deleteValue(key: symbol): Context;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { TraceState } from \"../../interfaces\";\n\n/**\n * @internal\n */\nexport class OpenCensusTraceStateWrapper implements TraceState {\n  private readonly _state?: string;\n\n  constructor(state?: string) {\n    this._state = state;\n  }\n\n  get(_key: string): string | undefined {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  set(_key: string, _value: string): TraceState {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  unset(_key: string): TraceState {\n    throw new Error(\"Method not implemented\");\n  }\n\n  serialize(): string {\n    return this._state || \"\";\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  Context as OTContext,\n  context as otContext,\n  SpanContext,\n  Span,\n  SpanOptions,\n  SpanAttributes,\n  SpanStatus,\n  TraceFlags,\n  Exception,\n  TimeInput,\n  SpanStatusCode,\n  getSpan\n} from \"../../interfaces\";\nimport { OpenCensusTraceStateWrapper } from \"./openCensusTraceStateWrapper\";\nimport { OpenCensusTracerWrapper } from \"./openCensusTracerWrapper\";\nimport { Attributes as OpenCensusAttributes, Span as OpenCensusSpan } from \"@opencensus/web-types\";\n\n/** An enumeration of canonical status codes. */\nenum CanonicalCode {\n  /**\n   * Not an error; returned on success\n   */\n  OK = 0,\n  /**\n   * Internal errors.  Means some invariants expected by underlying\n   * system has been broken.  If you see one of these errors,\n   * something is very broken.\n   */\n  INTERNAL = 13\n}\n\nfunction isWrappedSpan(span?: Span | SpanContext | null): span is OpenCensusSpanWrapper {\n  return !!span && (span as OpenCensusSpanWrapper).getWrappedSpan !== undefined;\n}\n\nfunction isTracer(\n  tracerOrSpan: OpenCensusTracerWrapper | OpenCensusSpan\n): tracerOrSpan is OpenCensusTracerWrapper {\n  return (tracerOrSpan as OpenCensusTracerWrapper).getWrappedTracer !== undefined;\n}\n\n/**\n * An implementation of OpenTelemetry Span that wraps an OpenCensus Span.\n */\nexport class OpenCensusSpanWrapper implements Span {\n  private _span: OpenCensusSpan;\n\n  /**\n   * The underlying OpenCensus Span\n   */\n  public getWrappedSpan(): OpenCensusSpan {\n    return this._span;\n  }\n\n  /**\n   * Wraps an existing OpenCensus Span\n   * @param span - A Span or RootSpan from OpenCensus\n   */\n  constructor(span: OpenCensusSpan);\n  /**\n   * Create a new OpenCensus Span and wrap it.\n   * @param tracer - The OpenCensus tracer that has been wrapped in OpenCensusTracerWrapper\n   * @param name - The name of the Span\n   * @param options - Options for the Span\n   * @param context - The context for the Span.\n   */\n  constructor(\n    tracer: OpenCensusTracerWrapper,\n    name: string,\n    options?: SpanOptions,\n    context?: OTContext\n  );\n  constructor(\n    tracerOrSpan: OpenCensusTracerWrapper | OpenCensusSpan,\n    name: string = \"\",\n    options: SpanOptions = {},\n    context?: OTContext\n  ) {\n    if (isTracer(tracerOrSpan)) {\n      const span = getSpan(context ?? otContext.active());\n      const parent = isWrappedSpan(span) ? span.getWrappedSpan() : undefined;\n      this._span = tracerOrSpan.getWrappedTracer().startChildSpan({\n        name,\n        childOf: parent\n      });\n      this._span.start();\n      if (options.links) {\n        for (const link of options.links) {\n          // Since there is no way to set the link relationship, leave it as Unspecified.\n          this._span.addLink(\n            link.context.traceId,\n            link.context.spanId,\n            0 /* LinkType.UNSPECIFIED */,\n            link.attributes as OpenCensusAttributes\n          );\n        }\n      }\n    } else {\n      this._span = tracerOrSpan;\n    }\n  }\n\n  /**\n   * Marks the end of Span execution.\n   * @param endTime - The time to use as the Span's end time. Defaults to\n   * the current time.\n   */\n  end(_endTime?: number): void {\n    this._span.end();\n  }\n\n  /**\n   * Returns the SpanContext associated with this Span.\n   */\n  context(): SpanContext {\n    const openCensusSpanContext = this._span.spanContext;\n\n    return {\n      spanId: openCensusSpanContext.spanId,\n      traceId: openCensusSpanContext.traceId,\n      traceFlags: openCensusSpanContext.options as TraceFlags,\n      traceState: new OpenCensusTraceStateWrapper(openCensusSpanContext.traceState)\n    };\n  }\n\n  /**\n   * Sets an attribute on the Span\n   * @param key - The attribute key\n   * @param value - The attribute value\n   */\n  setAttribute(key: string, value: unknown): this {\n    this._span.addAttribute(key, value as any);\n    return this;\n  }\n\n  /**\n   * Sets attributes on the Span\n   * @param attributes - The attributes to add\n   */\n  setAttributes(attributes: SpanAttributes): this {\n    this._span.attributes = attributes as OpenCensusAttributes;\n    return this;\n  }\n\n  /**\n   * Adds an event to the Span\n   * @param name - The name of the event\n   * @param attributes - The associated attributes to add for this event\n   */\n  addEvent(_name: string, _attributes?: SpanAttributes): this {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /**\n   * Sets a status on the span. Overrides the default of SpanStatusCode.OK.\n   * @param status - The status to set.\n   */\n  setStatus(status: SpanStatus): this {\n    switch (status.code) {\n      case SpanStatusCode.ERROR: {\n        this._span.setStatus(CanonicalCode.INTERNAL, status.message);\n        break;\n      }\n      case SpanStatusCode.OK: {\n        this._span.setStatus(CanonicalCode.OK, status.message);\n        break;\n      }\n      case SpanStatusCode.UNSET: {\n        break;\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Updates the name of the Span\n   * @param name - The new Span name\n   */\n  updateName(name: string): this {\n    this._span.name = name;\n    return this;\n  }\n\n  /**\n   * Returns whether this span will be recorded\n   */\n  isRecording(): boolean {\n    // NoRecordSpans have an empty traceId\n    return !!this._span.traceId;\n  }\n\n  /**\n   * Sets exception as a span event\n   * @param exception - the exception the only accepted values are string or Error\n   * @param time - the time to set as Span's event time. If not provided,\n   *     use the current time.\n   */\n  recordException(_exception: Exception, _time?: TimeInput): void {\n    throw new Error(\"Method not implemented\");\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Tracer } from \"../../interfaces\";\nimport { OpenCensusSpanWrapper } from \"./openCensusSpanWrapper\";\nimport { TracerBase as OpenCensusTracer } from \"@opencensus/web-types\";\nimport { Span, SpanOptions } from \"../../interfaces\";\n\n/**\n * An implementation of OpenTelemetry Tracer that wraps an OpenCensus Tracer.\n */\nexport class OpenCensusTracerWrapper implements Tracer {\n  private _tracer: OpenCensusTracer;\n\n  /**\n   * The wrapped OpenCensus Tracer\n   */\n  public getWrappedTracer(): OpenCensusTracer {\n    return this._tracer;\n  }\n\n  /**\n   * Create a new wrapper around a given OpenCensus Tracer.\n   * @param tracer - The OpenCensus Tracer to wrap.\n   */\n  public constructor(tracer: OpenCensusTracer) {\n    this._tracer = tracer;\n  }\n\n  /**\n   * Starts a new Span.\n   * @param name - The name of the span.\n   * @param options - The SpanOptions used during Span creation.\n   */\n  startSpan(name: string, options?: SpanOptions): Span {\n    return new OpenCensusSpanWrapper(this, name, options);\n  }\n\n  /**\n   * Returns the current Span from the current context, if available.\n   */\n  getCurrentSpan(): Span | undefined {\n    return undefined;\n  }\n\n  /**\n   * Executes the given function within the context provided by a Span.\n   * @param _span - The span that provides the context.\n   * @param _fn - The function to be executed.\n   */\n  withSpan<T extends (...args: unknown[]) => unknown>(_span: Span, _fn: T): ReturnType<T> {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /**\n   * Bind a Span as the target's scope\n   * @param target - An object to bind the scope.\n   * @param _span - A specific Span to use. Otherwise, use the current one.\n   */\n  bind<T>(_target: T, _span?: Span): T {\n    throw new Error(\"Method not implemented.\");\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  TimeInput,\n  Tracer,\n  SpanKind,\n  SpanStatus,\n  SpanContext,\n  SpanAttributes,\n  SpanStatusCode,\n  SpanAttributeValue\n} from \"../../interfaces\";\nimport { NoOpSpan } from \"../noop/noOpSpan\";\n\n/**\n * A mock span useful for testing.\n */\nexport class TestSpan extends NoOpSpan {\n  /**\n   * The Span's current name\n   */\n  name: string;\n\n  /**\n   * The Span's current status\n   */\n  status: SpanStatus;\n\n  /**\n   * The Span's kind\n   */\n  kind: SpanKind;\n\n  /**\n   * True if end() has been called on the Span\n   */\n  endCalled: boolean;\n\n  /**\n   * The start time of the Span\n   */\n  readonly startTime: TimeInput;\n\n  /**\n   * The id of the parent Span, if any.\n   */\n  readonly parentSpanId?: string;\n\n  /**\n   * Known attributes, if any.\n   */\n  readonly attributes: SpanAttributes;\n\n  private _context: SpanContext;\n  private readonly _tracer: Tracer;\n\n  /**\n   * Starts a new Span.\n   * @param parentTracer-  The tracer that created this Span\n   * @param name - The name of the span.\n   * @param context - The SpanContext this span belongs to\n   * @param kind - The SpanKind of this Span\n   * @param parentSpanId - The identifier of the parent Span\n   * @param startTime - The startTime of the event (defaults to now)\n   */\n  constructor(\n    parentTracer: Tracer,\n    name: string,\n    context: SpanContext,\n    kind: SpanKind,\n    parentSpanId?: string,\n    startTime: TimeInput = Date.now()\n  ) {\n    super();\n    this._tracer = parentTracer;\n    this.name = name;\n    this.kind = kind;\n    this.startTime = startTime;\n    this.parentSpanId = parentSpanId;\n    this.status = {\n      code: SpanStatusCode.OK\n    };\n    this.endCalled = false;\n    this._context = context;\n    this.attributes = {};\n  }\n\n  /**\n   * Returns the Tracer that created this Span\n   */\n  tracer(): Tracer {\n    return this._tracer;\n  }\n\n  /**\n   * Returns the SpanContext associated with this Span.\n   */\n  context(): SpanContext {\n    return this._context;\n  }\n\n  /**\n   * Marks the end of Span execution.\n   * @param _endTime - The time to use as the Span's end time. Defaults to\n   * the current time.\n   */\n  end(_endTime?: number): void {\n    this.endCalled = true;\n  }\n\n  /**\n   * Sets a status on the span. Overrides the default of SpanStatusCode.OK.\n   * @param status - The status to set.\n   */\n  setStatus(status: SpanStatus): this {\n    this.status = status;\n    return this;\n  }\n\n  /**\n   * Returns whether this span will be recorded\n   */\n  isRecording(): boolean {\n    return true;\n  }\n\n  /**\n   * Sets an attribute on the Span\n   * @param key - The attribute key\n   * @param value - The attribute value\n   */\n  setAttribute(key: string, value: SpanAttributeValue): this {\n    this.attributes[key] = value;\n    return this;\n  }\n\n  /**\n   * Sets attributes on the Span\n   * @param attributes - The attributes to add\n   */\n  setAttributes(attributes: SpanAttributes): this {\n    for (const key of Object.keys(attributes)) {\n      this.attributes[key] = attributes[key];\n    }\n    return this;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { TestSpan } from \"./testSpan\";\nimport { NoOpTracer } from \"../noop/noOpTracer\";\nimport {\n  SpanContext,\n  SpanKind,\n  SpanOptions,\n  TraceFlags,\n  Context as OTContext,\n  context as otContext,\n  getSpanContext\n} from \"../../interfaces\";\n\n/**\n * Simple representation of a Span that only has name and child relationships.\n * Children should be arranged in the order they were created.\n */\nexport interface SpanGraphNode {\n  /**\n   * The Span name\n   */\n  name: string;\n  /**\n   * All child Spans of this Span\n   */\n  children: SpanGraphNode[];\n}\n\n/**\n * Contains all the spans for a particular TraceID\n * starting at unparented roots\n */\nexport interface SpanGraph {\n  /**\n   * All Spans without a parentSpanId\n   */\n  roots: SpanGraphNode[];\n}\n\n/**\n * A mock tracer useful for testing\n */\nexport class TestTracer extends NoOpTracer {\n  private traceIdCounter = 0;\n  private getNextTraceId(): string {\n    this.traceIdCounter++;\n    return String(this.traceIdCounter);\n  }\n\n  private spanIdCounter = 0;\n  private getNextSpanId(): string {\n    this.spanIdCounter++;\n    return String(this.spanIdCounter);\n  }\n\n  private rootSpans: TestSpan[] = [];\n  private knownSpans: TestSpan[] = [];\n\n  /**\n   * Returns all Spans that were created without a parent\n   */\n  getRootSpans(): TestSpan[] {\n    return this.rootSpans;\n  }\n\n  /**\n   * Returns all Spans this Tracer knows about\n   */\n  getKnownSpans(): TestSpan[] {\n    return this.knownSpans;\n  }\n\n  /**\n   * Returns all Spans where end() has not been called\n   */\n  getActiveSpans(): TestSpan[] {\n    return this.knownSpans.filter((span) => {\n      return !span.endCalled;\n    });\n  }\n\n  /**\n   * Return all Spans for a particular trace, grouped by their\n   * parent Span in a tree-like structure\n   * @param traceId - The traceId to return the graph for\n   */\n  getSpanGraph(traceId: string): SpanGraph {\n    const traceSpans = this.knownSpans.filter((span) => {\n      return span.context().traceId === traceId;\n    });\n\n    const roots: SpanGraphNode[] = [];\n    const nodeMap: Map<string, SpanGraphNode> = new Map<string, SpanGraphNode>();\n\n    for (const span of traceSpans) {\n      const spanId = span.context().spanId;\n      const node: SpanGraphNode = {\n        name: span.name,\n        children: []\n      };\n      nodeMap.set(spanId, node);\n      if (span.parentSpanId) {\n        const parent = nodeMap.get(span.parentSpanId);\n        if (!parent) {\n          throw new Error(\n            `Span with name ${node.name} has an unknown parentSpan with id ${span.parentSpanId}`\n          );\n        }\n        parent.children.push(node);\n      } else {\n        roots.push(node);\n      }\n    }\n\n    return {\n      roots\n    };\n  }\n\n  /**\n   * Starts a new Span.\n   * @param name - The name of the span.\n   * @param options - The SpanOptions used during Span creation.\n   */\n  startSpan(name: string, options?: SpanOptions, context?: OTContext): TestSpan {\n    const parentContext = getSpanContext(context || otContext.active());\n\n    let traceId: string;\n    let isRootSpan = false;\n\n    if (parentContext && parentContext.traceId) {\n      traceId = parentContext.traceId;\n    } else {\n      traceId = this.getNextTraceId();\n      isRootSpan = true;\n    }\n\n    const spanContext: SpanContext = {\n      traceId,\n      spanId: this.getNextSpanId(),\n      traceFlags: TraceFlags.NONE\n    };\n    const span = new TestSpan(\n      this,\n      name,\n      spanContext,\n      options?.kind || SpanKind.INTERNAL,\n      parentContext ? parentContext.spanId : undefined,\n      options?.startTime\n    );\n    this.knownSpans.push(span);\n    if (isRootSpan) {\n      this.rootSpans.push(span);\n    }\n    return span;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { getTracer } from \"../src/tracerProxy\";\nimport {\n  OperationTracingOptions,\n  Span,\n  SpanOptions,\n  SpanKind,\n  setSpan,\n  context as otContext\n} from \"./interfaces\";\n\n/**\n * Arguments for `createSpanFunction` that allow you to specify the\n * prefix for each created span as well as the `az.namespace` attribute.\n *\n * @hidden\n */\nexport interface CreateSpanFunctionArgs {\n  /**\n   * Package name prefix.\n   *\n   * NOTE: if this is empty no prefix will be applied to created Span names.\n   */\n  packagePrefix: string;\n  /**\n   * Service namespace\n   *\n   * NOTE: if this is empty no `az.namespace` attribute will be added to created Spans.\n   */\n  namespace: string;\n}\n\n/**\n * Creates a function that can be used to create spans using the global tracer.\n *\n * Usage:\n *\n * ```typescript\n * // once\n * const createSpan = createSpanFunction({ packagePrefix: \"Azure.Data.AppConfiguration\", namespace: \"Microsoft.AppConfiguration\" });\n *\n * // in each operation\n * const span = createSpan(\"deleteConfigurationSetting\", operationOptions);\n *    // code...\n * span.end();\n * ```\n *\n * @hidden\n * @param args - allows configuration of the prefix for each span as well as the az.namespace field.\n */\nexport function createSpanFunction(args: CreateSpanFunctionArgs) {\n  return function<T extends { tracingOptions?: OperationTracingOptions }>(\n    operationName: string,\n    operationOptions: T | undefined\n  ): { span: Span; updatedOptions: T } {\n    const tracer = getTracer();\n    const tracingOptions = operationOptions?.tracingOptions || {};\n    const spanOptions: SpanOptions = {\n      kind: SpanKind.INTERNAL,\n      ...tracingOptions.spanOptions\n    };\n\n    const spanName = args.packagePrefix ? `${args.packagePrefix}.${operationName}` : operationName;\n    const span = tracer.startSpan(spanName, spanOptions, tracingOptions.tracingContext);\n\n    if (args.namespace) {\n      span.setAttribute(\"az.namespace\", args.namespace);\n    }\n\n    let newSpanOptions = tracingOptions.spanOptions || {};\n\n    if (span.isRecording() && args.namespace) {\n      newSpanOptions = {\n        ...tracingOptions.spanOptions,\n        attributes: {\n          ...spanOptions.attributes,\n          \"az.namespace\": args.namespace\n        }\n      };\n    }\n\n    const newTracingOptions: Required<OperationTracingOptions> = {\n      ...tracingOptions,\n      spanOptions: newSpanOptions,\n      tracingContext: setSpan(tracingOptions.tracingContext || otContext.active(), span)\n    };\n\n    const newOperationOptions = {\n      ...operationOptions,\n      tracingOptions: newTracingOptions\n    } as T & { tracingOptions: Required<OperationTracingOptions> };\n\n    return {\n      span,\n      updatedOptions: newOperationOptions\n    };\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { SpanContext, TraceFlags } from \"../interfaces\";\n\nconst VERSION = \"00\";\n\n/**\n * Generates a `SpanContext` given a `traceparent` header value.\n * @param traceParent - Serialized span context data as a `traceparent` header value.\n * @returns The `SpanContext` generated from the `traceparent` value.\n */\nexport function extractSpanContextFromTraceParentHeader(\n  traceParentHeader: string\n): SpanContext | undefined {\n  const parts = traceParentHeader.split(\"-\");\n\n  if (parts.length !== 4) {\n    return;\n  }\n\n  const [version, traceId, spanId, traceOptions] = parts;\n\n  if (version !== VERSION) {\n    return;\n  }\n\n  const traceFlags = parseInt(traceOptions, 16);\n\n  const spanContext: SpanContext = {\n    spanId,\n    traceId,\n    traceFlags\n  };\n\n  return spanContext;\n}\n\n/**\n * Generates a `traceparent` value given a span context.\n * @param spanContext - Contains context for a specific span.\n * @returns The `spanContext` represented as a `traceparent` value.\n */\nexport function getTraceParentHeader(spanContext: SpanContext): string | undefined {\n  const missingFields: string[] = [];\n  if (!spanContext.traceId) {\n    missingFields.push(\"traceId\");\n  }\n  if (!spanContext.spanId) {\n    missingFields.push(\"spanId\");\n  }\n\n  if (missingFields.length) {\n    return;\n  }\n\n  const flags = spanContext.traceFlags || TraceFlags.NONE;\n  const hexFlags = flags.toString(16);\n  const traceFlags = hexFlags.length === 1 ? `0${hexFlags}` : hexFlags;\n\n  // https://www.w3.org/TR/trace-context/#traceparent-header-field-values\n  return `${VERSION}-${spanContext.traceId}-${spanContext.spanId}-${traceFlags}`;\n}\n"],"names":["SpanKind","otGetSpan","otSetSpan","otSetSpanContext","otGetSpanContext","otContext","SpanStatusCode","context","__extends","__assign"],"mappings":"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"}