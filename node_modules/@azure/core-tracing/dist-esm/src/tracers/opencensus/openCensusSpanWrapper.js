// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { context as otContext, SpanStatusCode, getSpan } from "../../interfaces";
import { OpenCensusTraceStateWrapper } from "./openCensusTraceStateWrapper";
/** An enumeration of canonical status codes. */
var CanonicalCode;
(function (CanonicalCode) {
    /**
     * Not an error; returned on success
     */
    CanonicalCode[CanonicalCode["OK"] = 0] = "OK";
    /**
     * Internal errors.  Means some invariants expected by underlying
     * system has been broken.  If you see one of these errors,
     * something is very broken.
     */
    CanonicalCode[CanonicalCode["INTERNAL"] = 13] = "INTERNAL";
})(CanonicalCode || (CanonicalCode = {}));
function isWrappedSpan(span) {
    return !!span && span.getWrappedSpan !== undefined;
}
function isTracer(tracerOrSpan) {
    return tracerOrSpan.getWrappedTracer !== undefined;
}
/**
 * An implementation of OpenTelemetry Span that wraps an OpenCensus Span.
 */
var OpenCensusSpanWrapper = /** @class */ (function () {
    function OpenCensusSpanWrapper(tracerOrSpan, name, options, context) {
        if (name === void 0) { name = ""; }
        if (options === void 0) { options = {}; }
        if (isTracer(tracerOrSpan)) {
            var span = getSpan(context !== null && context !== void 0 ? context : otContext.active());
            var parent = isWrappedSpan(span) ? span.getWrappedSpan() : undefined;
            this._span = tracerOrSpan.getWrappedTracer().startChildSpan({
                name: name,
                childOf: parent
            });
            this._span.start();
            if (options.links) {
                for (var _i = 0, _a = options.links; _i < _a.length; _i++) {
                    var link = _a[_i];
                    // Since there is no way to set the link relationship, leave it as Unspecified.
                    this._span.addLink(link.context.traceId, link.context.spanId, 0 /* LinkType.UNSPECIFIED */, link.attributes);
                }
            }
        }
        else {
            this._span = tracerOrSpan;
        }
    }
    /**
     * The underlying OpenCensus Span
     */
    OpenCensusSpanWrapper.prototype.getWrappedSpan = function () {
        return this._span;
    };
    /**
     * Marks the end of Span execution.
     * @param endTime - The time to use as the Span's end time. Defaults to
     * the current time.
     */
    OpenCensusSpanWrapper.prototype.end = function (_endTime) {
        this._span.end();
    };
    /**
     * Returns the SpanContext associated with this Span.
     */
    OpenCensusSpanWrapper.prototype.context = function () {
        var openCensusSpanContext = this._span.spanContext;
        return {
            spanId: openCensusSpanContext.spanId,
            traceId: openCensusSpanContext.traceId,
            traceFlags: openCensusSpanContext.options,
            traceState: new OpenCensusTraceStateWrapper(openCensusSpanContext.traceState)
        };
    };
    /**
     * Sets an attribute on the Span
     * @param key - The attribute key
     * @param value - The attribute value
     */
    OpenCensusSpanWrapper.prototype.setAttribute = function (key, value) {
        this._span.addAttribute(key, value);
        return this;
    };
    /**
     * Sets attributes on the Span
     * @param attributes - The attributes to add
     */
    OpenCensusSpanWrapper.prototype.setAttributes = function (attributes) {
        this._span.attributes = attributes;
        return this;
    };
    /**
     * Adds an event to the Span
     * @param name - The name of the event
     * @param attributes - The associated attributes to add for this event
     */
    OpenCensusSpanWrapper.prototype.addEvent = function (_name, _attributes) {
        throw new Error("Method not implemented.");
    };
    /**
     * Sets a status on the span. Overrides the default of SpanStatusCode.OK.
     * @param status - The status to set.
     */
    OpenCensusSpanWrapper.prototype.setStatus = function (status) {
        switch (status.code) {
            case SpanStatusCode.ERROR: {
                this._span.setStatus(CanonicalCode.INTERNAL, status.message);
                break;
            }
            case SpanStatusCode.OK: {
                this._span.setStatus(CanonicalCode.OK, status.message);
                break;
            }
            case SpanStatusCode.UNSET: {
                break;
            }
        }
        return this;
    };
    /**
     * Updates the name of the Span
     * @param name - The new Span name
     */
    OpenCensusSpanWrapper.prototype.updateName = function (name) {
        this._span.name = name;
        return this;
    };
    /**
     * Returns whether this span will be recorded
     */
    OpenCensusSpanWrapper.prototype.isRecording = function () {
        // NoRecordSpans have an empty traceId
        return !!this._span.traceId;
    };
    /**
     * Sets exception as a span event
     * @param exception - the exception the only accepted values are string or Error
     * @param time - the time to set as Span's event time. If not provided,
     *     use the current time.
     */
    OpenCensusSpanWrapper.prototype.recordException = function (_exception, _time) {
        throw new Error("Method not implemented");
    };
    return OpenCensusSpanWrapper;
}());
export { OpenCensusSpanWrapper };
//# sourceMappingURL=openCensusSpanWrapper.js.map